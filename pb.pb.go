// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb.proto

package pb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// 状态
type Status struct {
	Host *Status_Host `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	Load *Status_Load `protobuf:"bytes,2,opt,name=load,proto3" json:"load,omitempty"`
	Cpu  *Status_CPU  `protobuf:"bytes,3,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Mem  *Status_Mem  `protobuf:"bytes,4,opt,name=mem,proto3" json:"mem,omitempty"`
	Net  *Status_Net  `protobuf:"bytes,5,opt,name=net,proto3" json:"net,omitempty"`
	Disk *Status_Disk `protobuf:"bytes,6,opt,name=disk,proto3" json:"disk,omitempty"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetHost() *Status_Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Status) GetLoad() *Status_Load {
	if m != nil {
		return m.Load
	}
	return nil
}

func (m *Status) GetCpu() *Status_CPU {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *Status) GetMem() *Status_Mem {
	if m != nil {
		return m.Mem
	}
	return nil
}

func (m *Status) GetNet() *Status_Net {
	if m != nil {
		return m.Net
	}
	return nil
}

func (m *Status) GetDisk() *Status_Disk {
	if m != nil {
		return m.Disk
	}
	return nil
}

// Host 信息
type Status_Host struct {
	Info         *Status_Host_Info          `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	Temperatures []*Status_Host_Temperature `protobuf:"bytes,2,rep,name=temperatures,proto3" json:"temperatures,omitempty"`
}

func (m *Status_Host) Reset()         { *m = Status_Host{} }
func (m *Status_Host) String() string { return proto.CompactTextString(m) }
func (*Status_Host) ProtoMessage()    {}
func (*Status_Host) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 0}
}
func (m *Status_Host) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Host) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Host.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Host) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Host.Merge(m, src)
}
func (m *Status_Host) XXX_Size() int {
	return m.Size()
}
func (m *Status_Host) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Host.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Host proto.InternalMessageInfo

func (m *Status_Host) GetInfo() *Status_Host_Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Status_Host) GetTemperatures() []*Status_Host_Temperature {
	if m != nil {
		return m.Temperatures
	}
	return nil
}

type Status_Host_Info struct {
	// hostname 名称
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// 启动时间
	Uptime uint64 `protobuf:"varint,2,opt,name=uptime,proto3" json:"uptime,omitempty"`
	// boot 启动时间
	BootTime             uint64 `protobuf:"varint,3,opt,name=bootTime,proto3" json:"bootTime,omitempty"`
	Procs                uint64 `protobuf:"varint,4,opt,name=procs,proto3" json:"procs,omitempty"`
	Os                   string `protobuf:"bytes,5,opt,name=os,proto3" json:"os,omitempty"`
	Platform             string `protobuf:"bytes,6,opt,name=platform,proto3" json:"platform,omitempty"`
	PlatformFamily       string `protobuf:"bytes,7,opt,name=platformFamily,proto3" json:"platformFamily,omitempty"`
	PlatformVersion      string `protobuf:"bytes,8,opt,name=platformVersion,proto3" json:"platformVersion,omitempty"`
	KernelVersion        string `protobuf:"bytes,9,opt,name=kernelVersion,proto3" json:"kernelVersion,omitempty"`
	KernelArch           string `protobuf:"bytes,10,opt,name=kernelArch,proto3" json:"kernelArch,omitempty"`
	VirtualizationSystem string `protobuf:"bytes,11,opt,name=virtualizationSystem,proto3" json:"virtualizationSystem,omitempty"`
	VirtualizationRole   string `protobuf:"bytes,13,opt,name=virtualizationRole,proto3" json:"virtualizationRole,omitempty"`
	HostId               string `protobuf:"bytes,14,opt,name=hostId,proto3" json:"hostId,omitempty"`
}

func (m *Status_Host_Info) Reset()         { *m = Status_Host_Info{} }
func (m *Status_Host_Info) String() string { return proto.CompactTextString(m) }
func (*Status_Host_Info) ProtoMessage()    {}
func (*Status_Host_Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 0, 0}
}
func (m *Status_Host_Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Host_Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Host_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Host_Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Host_Info.Merge(m, src)
}
func (m *Status_Host_Info) XXX_Size() int {
	return m.Size()
}
func (m *Status_Host_Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Host_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Host_Info proto.InternalMessageInfo

func (m *Status_Host_Info) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Status_Host_Info) GetUptime() uint64 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *Status_Host_Info) GetBootTime() uint64 {
	if m != nil {
		return m.BootTime
	}
	return 0
}

func (m *Status_Host_Info) GetProcs() uint64 {
	if m != nil {
		return m.Procs
	}
	return 0
}

func (m *Status_Host_Info) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

func (m *Status_Host_Info) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *Status_Host_Info) GetPlatformFamily() string {
	if m != nil {
		return m.PlatformFamily
	}
	return ""
}

func (m *Status_Host_Info) GetPlatformVersion() string {
	if m != nil {
		return m.PlatformVersion
	}
	return ""
}

func (m *Status_Host_Info) GetKernelVersion() string {
	if m != nil {
		return m.KernelVersion
	}
	return ""
}

func (m *Status_Host_Info) GetKernelArch() string {
	if m != nil {
		return m.KernelArch
	}
	return ""
}

func (m *Status_Host_Info) GetVirtualizationSystem() string {
	if m != nil {
		return m.VirtualizationSystem
	}
	return ""
}

func (m *Status_Host_Info) GetVirtualizationRole() string {
	if m != nil {
		return m.VirtualizationRole
	}
	return ""
}

func (m *Status_Host_Info) GetHostId() string {
	if m != nil {
		return m.HostId
	}
	return ""
}

type Status_Host_Temperature struct {
	SensorKey      string  `protobuf:"bytes,1,opt,name=sensorKey,proto3" json:"sensorKey,omitempty"`
	Temperature    float64 `protobuf:"fixed64,2,opt,name=temperature,proto3" json:"temperature,omitempty"`
	SensorHigh     float64 `protobuf:"fixed64,3,opt,name=sensorHigh,proto3" json:"sensorHigh,omitempty"`
	SensorCritical float64 `protobuf:"fixed64,4,opt,name=sensorCritical,proto3" json:"sensorCritical,omitempty"`
}

func (m *Status_Host_Temperature) Reset()         { *m = Status_Host_Temperature{} }
func (m *Status_Host_Temperature) String() string { return proto.CompactTextString(m) }
func (*Status_Host_Temperature) ProtoMessage()    {}
func (*Status_Host_Temperature) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 0, 1}
}
func (m *Status_Host_Temperature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Host_Temperature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Host_Temperature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Host_Temperature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Host_Temperature.Merge(m, src)
}
func (m *Status_Host_Temperature) XXX_Size() int {
	return m.Size()
}
func (m *Status_Host_Temperature) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Host_Temperature.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Host_Temperature proto.InternalMessageInfo

func (m *Status_Host_Temperature) GetSensorKey() string {
	if m != nil {
		return m.SensorKey
	}
	return ""
}

func (m *Status_Host_Temperature) GetTemperature() float64 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *Status_Host_Temperature) GetSensorHigh() float64 {
	if m != nil {
		return m.SensorHigh
	}
	return 0
}

func (m *Status_Host_Temperature) GetSensorCritical() float64 {
	if m != nil {
		return m.SensorCritical
	}
	return 0
}

// load
type Status_Load struct {
	Load1  float64 `protobuf:"fixed64,1,opt,name=load1,proto3" json:"load1,omitempty"`
	Load5  float64 `protobuf:"fixed64,2,opt,name=load5,proto3" json:"load5,omitempty"`
	Load15 float64 `protobuf:"fixed64,3,opt,name=load15,proto3" json:"load15,omitempty"`
}

func (m *Status_Load) Reset()         { *m = Status_Load{} }
func (m *Status_Load) String() string { return proto.CompactTextString(m) }
func (*Status_Load) ProtoMessage()    {}
func (*Status_Load) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 1}
}
func (m *Status_Load) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Load) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Load.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Load) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Load.Merge(m, src)
}
func (m *Status_Load) XXX_Size() int {
	return m.Size()
}
func (m *Status_Load) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Load.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Load proto.InternalMessageInfo

func (m *Status_Load) GetLoad1() float64 {
	if m != nil {
		return m.Load1
	}
	return 0
}

func (m *Status_Load) GetLoad5() float64 {
	if m != nil {
		return m.Load5
	}
	return 0
}

func (m *Status_Load) GetLoad15() float64 {
	if m != nil {
		return m.Load15
	}
	return 0
}

type Status_CPU struct {
	Infos []*Status_CPU_Info `protobuf:"bytes,1,rep,name=infos,proto3" json:"infos,omitempty"`
	Stats []*Status_CPU_Stat `protobuf:"bytes,2,rep,name=stats,proto3" json:"stats,omitempty"`
}

func (m *Status_CPU) Reset()         { *m = Status_CPU{} }
func (m *Status_CPU) String() string { return proto.CompactTextString(m) }
func (*Status_CPU) ProtoMessage()    {}
func (*Status_CPU) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 2}
}
func (m *Status_CPU) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_CPU) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_CPU.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_CPU) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_CPU.Merge(m, src)
}
func (m *Status_CPU) XXX_Size() int {
	return m.Size()
}
func (m *Status_CPU) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_CPU.DiscardUnknown(m)
}

var xxx_messageInfo_Status_CPU proto.InternalMessageInfo

func (m *Status_CPU) GetInfos() []*Status_CPU_Info {
	if m != nil {
		return m.Infos
	}
	return nil
}

func (m *Status_CPU) GetStats() []*Status_CPU_Stat {
	if m != nil {
		return m.Stats
	}
	return nil
}

type Status_CPU_Info struct {
	Cpu        int32    `protobuf:"varint,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	VendorId   string   `protobuf:"bytes,2,opt,name=vendorId,proto3" json:"vendorId,omitempty"`
	Family     string   `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Model      string   `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	Stepping   int32    `protobuf:"varint,5,opt,name=stepping,proto3" json:"stepping,omitempty"`
	PhysicalId string   `protobuf:"bytes,6,opt,name=physicalId,proto3" json:"physicalId,omitempty"`
	CoreId     string   `protobuf:"bytes,7,opt,name=coreId,proto3" json:"coreId,omitempty"`
	Cores      int32    `protobuf:"varint,8,opt,name=cores,proto3" json:"cores,omitempty"`
	ModelName  string   `protobuf:"bytes,9,opt,name=modelName,proto3" json:"modelName,omitempty"`
	Mhz        float64  `protobuf:"fixed64,10,opt,name=mhz,proto3" json:"mhz,omitempty"`
	CacheSize  int32    `protobuf:"varint,11,opt,name=cacheSize,proto3" json:"cacheSize,omitempty"`
	Flags      []string `protobuf:"bytes,12,rep,name=flags,proto3" json:"flags,omitempty"`
	Microcode  string   `protobuf:"bytes,13,opt,name=microcode,proto3" json:"microcode,omitempty"`
}

func (m *Status_CPU_Info) Reset()         { *m = Status_CPU_Info{} }
func (m *Status_CPU_Info) String() string { return proto.CompactTextString(m) }
func (*Status_CPU_Info) ProtoMessage()    {}
func (*Status_CPU_Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 2, 0}
}
func (m *Status_CPU_Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_CPU_Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_CPU_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_CPU_Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_CPU_Info.Merge(m, src)
}
func (m *Status_CPU_Info) XXX_Size() int {
	return m.Size()
}
func (m *Status_CPU_Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_CPU_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Status_CPU_Info proto.InternalMessageInfo

func (m *Status_CPU_Info) GetCpu() int32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *Status_CPU_Info) GetVendorId() string {
	if m != nil {
		return m.VendorId
	}
	return ""
}

func (m *Status_CPU_Info) GetFamily() string {
	if m != nil {
		return m.Family
	}
	return ""
}

func (m *Status_CPU_Info) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *Status_CPU_Info) GetStepping() int32 {
	if m != nil {
		return m.Stepping
	}
	return 0
}

func (m *Status_CPU_Info) GetPhysicalId() string {
	if m != nil {
		return m.PhysicalId
	}
	return ""
}

func (m *Status_CPU_Info) GetCoreId() string {
	if m != nil {
		return m.CoreId
	}
	return ""
}

func (m *Status_CPU_Info) GetCores() int32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *Status_CPU_Info) GetModelName() string {
	if m != nil {
		return m.ModelName
	}
	return ""
}

func (m *Status_CPU_Info) GetMhz() float64 {
	if m != nil {
		return m.Mhz
	}
	return 0
}

func (m *Status_CPU_Info) GetCacheSize() int32 {
	if m != nil {
		return m.CacheSize
	}
	return 0
}

func (m *Status_CPU_Info) GetFlags() []string {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *Status_CPU_Info) GetMicrocode() string {
	if m != nil {
		return m.Microcode
	}
	return ""
}

type Status_CPU_Stat struct {
	Cpu       string  `protobuf:"bytes,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	User      float64 `protobuf:"fixed64,2,opt,name=user,proto3" json:"user,omitempty"`
	System    float64 `protobuf:"fixed64,3,opt,name=system,proto3" json:"system,omitempty"`
	Idle      float64 `protobuf:"fixed64,4,opt,name=idle,proto3" json:"idle,omitempty"`
	Nice      float64 `protobuf:"fixed64,5,opt,name=nice,proto3" json:"nice,omitempty"`
	Iowait    float64 `protobuf:"fixed64,6,opt,name=iowait,proto3" json:"iowait,omitempty"`
	Irq       float64 `protobuf:"fixed64,7,opt,name=irq,proto3" json:"irq,omitempty"`
	Softirq   float64 `protobuf:"fixed64,8,opt,name=softirq,proto3" json:"softirq,omitempty"`
	Steal     float64 `protobuf:"fixed64,9,opt,name=steal,proto3" json:"steal,omitempty"`
	Guest     float64 `protobuf:"fixed64,10,opt,name=guest,proto3" json:"guest,omitempty"`
	GuestNice float64 `protobuf:"fixed64,11,opt,name=guestNice,proto3" json:"guestNice,omitempty"`
}

func (m *Status_CPU_Stat) Reset()         { *m = Status_CPU_Stat{} }
func (m *Status_CPU_Stat) String() string { return proto.CompactTextString(m) }
func (*Status_CPU_Stat) ProtoMessage()    {}
func (*Status_CPU_Stat) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 2, 1}
}
func (m *Status_CPU_Stat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_CPU_Stat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_CPU_Stat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_CPU_Stat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_CPU_Stat.Merge(m, src)
}
func (m *Status_CPU_Stat) XXX_Size() int {
	return m.Size()
}
func (m *Status_CPU_Stat) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_CPU_Stat.DiscardUnknown(m)
}

var xxx_messageInfo_Status_CPU_Stat proto.InternalMessageInfo

func (m *Status_CPU_Stat) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

func (m *Status_CPU_Stat) GetUser() float64 {
	if m != nil {
		return m.User
	}
	return 0
}

func (m *Status_CPU_Stat) GetSystem() float64 {
	if m != nil {
		return m.System
	}
	return 0
}

func (m *Status_CPU_Stat) GetIdle() float64 {
	if m != nil {
		return m.Idle
	}
	return 0
}

func (m *Status_CPU_Stat) GetNice() float64 {
	if m != nil {
		return m.Nice
	}
	return 0
}

func (m *Status_CPU_Stat) GetIowait() float64 {
	if m != nil {
		return m.Iowait
	}
	return 0
}

func (m *Status_CPU_Stat) GetIrq() float64 {
	if m != nil {
		return m.Irq
	}
	return 0
}

func (m *Status_CPU_Stat) GetSoftirq() float64 {
	if m != nil {
		return m.Softirq
	}
	return 0
}

func (m *Status_CPU_Stat) GetSteal() float64 {
	if m != nil {
		return m.Steal
	}
	return 0
}

func (m *Status_CPU_Stat) GetGuest() float64 {
	if m != nil {
		return m.Guest
	}
	return 0
}

func (m *Status_CPU_Stat) GetGuestNice() float64 {
	if m != nil {
		return m.GuestNice
	}
	return 0
}

type Status_Mem struct {
	Virtual *Status_Mem_Virtual `protobuf:"bytes,1,opt,name=virtual,proto3" json:"virtual,omitempty"`
	Swap    *Status_Mem_Swap    `protobuf:"bytes,2,opt,name=swap,proto3" json:"swap,omitempty"`
}

func (m *Status_Mem) Reset()         { *m = Status_Mem{} }
func (m *Status_Mem) String() string { return proto.CompactTextString(m) }
func (*Status_Mem) ProtoMessage()    {}
func (*Status_Mem) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 3}
}
func (m *Status_Mem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Mem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Mem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Mem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Mem.Merge(m, src)
}
func (m *Status_Mem) XXX_Size() int {
	return m.Size()
}
func (m *Status_Mem) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Mem.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Mem proto.InternalMessageInfo

func (m *Status_Mem) GetVirtual() *Status_Mem_Virtual {
	if m != nil {
		return m.Virtual
	}
	return nil
}

func (m *Status_Mem) GetSwap() *Status_Mem_Swap {
	if m != nil {
		return m.Swap
	}
	return nil
}

type Status_Mem_Virtual struct {
	Total       uint64  `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Available   uint64  `protobuf:"varint,2,opt,name=available,proto3" json:"available,omitempty"`
	Used        uint64  `protobuf:"varint,3,opt,name=used,proto3" json:"used,omitempty"`
	UsedPercent float64 `protobuf:"fixed64,4,opt,name=usedPercent,proto3" json:"usedPercent,omitempty"`
	Free        uint64  `protobuf:"varint,5,opt,name=free,proto3" json:"free,omitempty"`
}

func (m *Status_Mem_Virtual) Reset()         { *m = Status_Mem_Virtual{} }
func (m *Status_Mem_Virtual) String() string { return proto.CompactTextString(m) }
func (*Status_Mem_Virtual) ProtoMessage()    {}
func (*Status_Mem_Virtual) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 3, 0}
}
func (m *Status_Mem_Virtual) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Mem_Virtual) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Mem_Virtual.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Mem_Virtual) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Mem_Virtual.Merge(m, src)
}
func (m *Status_Mem_Virtual) XXX_Size() int {
	return m.Size()
}
func (m *Status_Mem_Virtual) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Mem_Virtual.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Mem_Virtual proto.InternalMessageInfo

func (m *Status_Mem_Virtual) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *Status_Mem_Virtual) GetAvailable() uint64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *Status_Mem_Virtual) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *Status_Mem_Virtual) GetUsedPercent() float64 {
	if m != nil {
		return m.UsedPercent
	}
	return 0
}

func (m *Status_Mem_Virtual) GetFree() uint64 {
	if m != nil {
		return m.Free
	}
	return 0
}

type Status_Mem_Swap struct {
	Total       uint64  `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Used        uint64  `protobuf:"varint,2,opt,name=used,proto3" json:"used,omitempty"`
	Free        uint64  `protobuf:"varint,3,opt,name=free,proto3" json:"free,omitempty"`
	UsedPercent float64 `protobuf:"fixed64,4,opt,name=usedPercent,proto3" json:"usedPercent,omitempty"`
	Sin         uint64  `protobuf:"varint,5,opt,name=sin,proto3" json:"sin,omitempty"`
	Sout        uint64  `protobuf:"varint,6,opt,name=sout,proto3" json:"sout,omitempty"`
	PgIn        uint64  `protobuf:"varint,7,opt,name=pgIn,proto3" json:"pgIn,omitempty"`
	PgOut       uint64  `protobuf:"varint,8,opt,name=pgOut,proto3" json:"pgOut,omitempty"`
	PgFault     uint64  `protobuf:"varint,9,opt,name=pgFault,proto3" json:"pgFault,omitempty"`
}

func (m *Status_Mem_Swap) Reset()         { *m = Status_Mem_Swap{} }
func (m *Status_Mem_Swap) String() string { return proto.CompactTextString(m) }
func (*Status_Mem_Swap) ProtoMessage()    {}
func (*Status_Mem_Swap) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 3, 1}
}
func (m *Status_Mem_Swap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Mem_Swap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Mem_Swap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Mem_Swap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Mem_Swap.Merge(m, src)
}
func (m *Status_Mem_Swap) XXX_Size() int {
	return m.Size()
}
func (m *Status_Mem_Swap) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Mem_Swap.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Mem_Swap proto.InternalMessageInfo

func (m *Status_Mem_Swap) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *Status_Mem_Swap) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *Status_Mem_Swap) GetFree() uint64 {
	if m != nil {
		return m.Free
	}
	return 0
}

func (m *Status_Mem_Swap) GetUsedPercent() float64 {
	if m != nil {
		return m.UsedPercent
	}
	return 0
}

func (m *Status_Mem_Swap) GetSin() uint64 {
	if m != nil {
		return m.Sin
	}
	return 0
}

func (m *Status_Mem_Swap) GetSout() uint64 {
	if m != nil {
		return m.Sout
	}
	return 0
}

func (m *Status_Mem_Swap) GetPgIn() uint64 {
	if m != nil {
		return m.PgIn
	}
	return 0
}

func (m *Status_Mem_Swap) GetPgOut() uint64 {
	if m != nil {
		return m.PgOut
	}
	return 0
}

func (m *Status_Mem_Swap) GetPgFault() uint64 {
	if m != nil {
		return m.PgFault
	}
	return 0
}

type Status_Net struct {
	Infos []*Status_Net_Info `protobuf:"bytes,1,rep,name=infos,proto3" json:"infos,omitempty"`
	Stats []*Status_Net_Stat `protobuf:"bytes,2,rep,name=stats,proto3" json:"stats,omitempty"`
}

func (m *Status_Net) Reset()         { *m = Status_Net{} }
func (m *Status_Net) String() string { return proto.CompactTextString(m) }
func (*Status_Net) ProtoMessage()    {}
func (*Status_Net) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 4}
}
func (m *Status_Net) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Net) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Net.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Net) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Net.Merge(m, src)
}
func (m *Status_Net) XXX_Size() int {
	return m.Size()
}
func (m *Status_Net) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Net.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Net proto.InternalMessageInfo

func (m *Status_Net) GetInfos() []*Status_Net_Info {
	if m != nil {
		return m.Infos
	}
	return nil
}

func (m *Status_Net) GetStats() []*Status_Net_Stat {
	if m != nil {
		return m.Stats
	}
	return nil
}

type Status_Net_Info struct {
	Index        int32    `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Mtu          int32    `protobuf:"varint,2,opt,name=mtu,proto3" json:"mtu,omitempty"`
	Name         string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	HardwareAddr string   `protobuf:"bytes,4,opt,name=hardwareAddr,proto3" json:"hardwareAddr,omitempty"`
	Flags        []string `protobuf:"bytes,5,rep,name=flags,proto3" json:"flags,omitempty"`
	AddrList     []string `protobuf:"bytes,6,rep,name=addrList,proto3" json:"addrList,omitempty"`
}

func (m *Status_Net_Info) Reset()         { *m = Status_Net_Info{} }
func (m *Status_Net_Info) String() string { return proto.CompactTextString(m) }
func (*Status_Net_Info) ProtoMessage()    {}
func (*Status_Net_Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 4, 0}
}
func (m *Status_Net_Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Net_Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Net_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Net_Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Net_Info.Merge(m, src)
}
func (m *Status_Net_Info) XXX_Size() int {
	return m.Size()
}
func (m *Status_Net_Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Net_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Net_Info proto.InternalMessageInfo

func (m *Status_Net_Info) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Status_Net_Info) GetMtu() int32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *Status_Net_Info) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Status_Net_Info) GetHardwareAddr() string {
	if m != nil {
		return m.HardwareAddr
	}
	return ""
}

func (m *Status_Net_Info) GetFlags() []string {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *Status_Net_Info) GetAddrList() []string {
	if m != nil {
		return m.AddrList
	}
	return nil
}

type Status_Net_Stat struct {
	Name        string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	BytesSent   uint64 `protobuf:"varint,2,opt,name=bytesSent,proto3" json:"bytesSent,omitempty"`
	BytesRecv   uint64 `protobuf:"varint,3,opt,name=bytesRecv,proto3" json:"bytesRecv,omitempty"`
	PacketsSent uint64 `protobuf:"varint,4,opt,name=packetsSent,proto3" json:"packetsSent,omitempty"`
	PacketsRecv uint64 `protobuf:"varint,5,opt,name=packetsRecv,proto3" json:"packetsRecv,omitempty"`
	Errin       uint64 `protobuf:"varint,6,opt,name=errin,proto3" json:"errin,omitempty"`
	Errout      uint64 `protobuf:"varint,7,opt,name=errout,proto3" json:"errout,omitempty"`
	Dropin      uint64 `protobuf:"varint,8,opt,name=dropin,proto3" json:"dropin,omitempty"`
	Dropout     uint64 `protobuf:"varint,9,opt,name=dropout,proto3" json:"dropout,omitempty"`
	Fifoin      uint64 `protobuf:"varint,10,opt,name=fifoin,proto3" json:"fifoin,omitempty"`
	Fifoout     uint64 `protobuf:"varint,11,opt,name=fifoout,proto3" json:"fifoout,omitempty"`
}

func (m *Status_Net_Stat) Reset()         { *m = Status_Net_Stat{} }
func (m *Status_Net_Stat) String() string { return proto.CompactTextString(m) }
func (*Status_Net_Stat) ProtoMessage()    {}
func (*Status_Net_Stat) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 4, 1}
}
func (m *Status_Net_Stat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Net_Stat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Net_Stat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Net_Stat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Net_Stat.Merge(m, src)
}
func (m *Status_Net_Stat) XXX_Size() int {
	return m.Size()
}
func (m *Status_Net_Stat) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Net_Stat.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Net_Stat proto.InternalMessageInfo

func (m *Status_Net_Stat) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Status_Net_Stat) GetBytesSent() uint64 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *Status_Net_Stat) GetBytesRecv() uint64 {
	if m != nil {
		return m.BytesRecv
	}
	return 0
}

func (m *Status_Net_Stat) GetPacketsSent() uint64 {
	if m != nil {
		return m.PacketsSent
	}
	return 0
}

func (m *Status_Net_Stat) GetPacketsRecv() uint64 {
	if m != nil {
		return m.PacketsRecv
	}
	return 0
}

func (m *Status_Net_Stat) GetErrin() uint64 {
	if m != nil {
		return m.Errin
	}
	return 0
}

func (m *Status_Net_Stat) GetErrout() uint64 {
	if m != nil {
		return m.Errout
	}
	return 0
}

func (m *Status_Net_Stat) GetDropin() uint64 {
	if m != nil {
		return m.Dropin
	}
	return 0
}

func (m *Status_Net_Stat) GetDropout() uint64 {
	if m != nil {
		return m.Dropout
	}
	return 0
}

func (m *Status_Net_Stat) GetFifoin() uint64 {
	if m != nil {
		return m.Fifoin
	}
	return 0
}

func (m *Status_Net_Stat) GetFifoout() uint64 {
	if m != nil {
		return m.Fifoout
	}
	return 0
}

type Status_Disk struct {
	Infos []*Status_Disk_Info `protobuf:"bytes,1,rep,name=infos,proto3" json:"infos,omitempty"`
	Stats []*Status_Disk_Stat `protobuf:"bytes,2,rep,name=stats,proto3" json:"stats,omitempty"`
	Ios   []*Status_Disk_IO   `protobuf:"bytes,3,rep,name=ios,proto3" json:"ios,omitempty"`
}

func (m *Status_Disk) Reset()         { *m = Status_Disk{} }
func (m *Status_Disk) String() string { return proto.CompactTextString(m) }
func (*Status_Disk) ProtoMessage()    {}
func (*Status_Disk) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 5}
}
func (m *Status_Disk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Disk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Disk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Disk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Disk.Merge(m, src)
}
func (m *Status_Disk) XXX_Size() int {
	return m.Size()
}
func (m *Status_Disk) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Disk.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Disk proto.InternalMessageInfo

func (m *Status_Disk) GetInfos() []*Status_Disk_Info {
	if m != nil {
		return m.Infos
	}
	return nil
}

func (m *Status_Disk) GetStats() []*Status_Disk_Stat {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *Status_Disk) GetIos() []*Status_Disk_IO {
	if m != nil {
		return m.Ios
	}
	return nil
}

type Status_Disk_Info struct {
	Device     string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	Mountpoint string `protobuf:"bytes,2,opt,name=mountpoint,proto3" json:"mountpoint,omitempty"`
	Fstype     string `protobuf:"bytes,3,opt,name=fstype,proto3" json:"fstype,omitempty"`
}

func (m *Status_Disk_Info) Reset()         { *m = Status_Disk_Info{} }
func (m *Status_Disk_Info) String() string { return proto.CompactTextString(m) }
func (*Status_Disk_Info) ProtoMessage()    {}
func (*Status_Disk_Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 5, 0}
}
func (m *Status_Disk_Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Disk_Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Disk_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Disk_Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Disk_Info.Merge(m, src)
}
func (m *Status_Disk_Info) XXX_Size() int {
	return m.Size()
}
func (m *Status_Disk_Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Disk_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Disk_Info proto.InternalMessageInfo

func (m *Status_Disk_Info) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *Status_Disk_Info) GetMountpoint() string {
	if m != nil {
		return m.Mountpoint
	}
	return ""
}

func (m *Status_Disk_Info) GetFstype() string {
	if m != nil {
		return m.Fstype
	}
	return ""
}

type Status_Disk_Stat struct {
	Path              string  `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Fstype            string  `protobuf:"bytes,2,opt,name=fstype,proto3" json:"fstype,omitempty"`
	Total             uint64  `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	Free              uint64  `protobuf:"varint,4,opt,name=free,proto3" json:"free,omitempty"`
	Used              uint64  `protobuf:"varint,5,opt,name=used,proto3" json:"used,omitempty"`
	UsedPercent       float64 `protobuf:"fixed64,6,opt,name=usedPercent,proto3" json:"usedPercent,omitempty"`
	InodesTotal       uint64  `protobuf:"varint,7,opt,name=inodesTotal,proto3" json:"inodesTotal,omitempty"`
	InodesUsed        uint64  `protobuf:"varint,8,opt,name=inodesUsed,proto3" json:"inodesUsed,omitempty"`
	InodesFree        uint64  `protobuf:"varint,9,opt,name=inodesFree,proto3" json:"inodesFree,omitempty"`
	InodesUsedPercent float64 `protobuf:"fixed64,10,opt,name=inodesUsedPercent,proto3" json:"inodesUsedPercent,omitempty"`
}

func (m *Status_Disk_Stat) Reset()         { *m = Status_Disk_Stat{} }
func (m *Status_Disk_Stat) String() string { return proto.CompactTextString(m) }
func (*Status_Disk_Stat) ProtoMessage()    {}
func (*Status_Disk_Stat) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 5, 1}
}
func (m *Status_Disk_Stat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Disk_Stat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Disk_Stat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Disk_Stat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Disk_Stat.Merge(m, src)
}
func (m *Status_Disk_Stat) XXX_Size() int {
	return m.Size()
}
func (m *Status_Disk_Stat) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Disk_Stat.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Disk_Stat proto.InternalMessageInfo

func (m *Status_Disk_Stat) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Status_Disk_Stat) GetFstype() string {
	if m != nil {
		return m.Fstype
	}
	return ""
}

func (m *Status_Disk_Stat) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *Status_Disk_Stat) GetFree() uint64 {
	if m != nil {
		return m.Free
	}
	return 0
}

func (m *Status_Disk_Stat) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *Status_Disk_Stat) GetUsedPercent() float64 {
	if m != nil {
		return m.UsedPercent
	}
	return 0
}

func (m *Status_Disk_Stat) GetInodesTotal() uint64 {
	if m != nil {
		return m.InodesTotal
	}
	return 0
}

func (m *Status_Disk_Stat) GetInodesUsed() uint64 {
	if m != nil {
		return m.InodesUsed
	}
	return 0
}

func (m *Status_Disk_Stat) GetInodesFree() uint64 {
	if m != nil {
		return m.InodesFree
	}
	return 0
}

func (m *Status_Disk_Stat) GetInodesUsedPercent() float64 {
	if m != nil {
		return m.InodesUsedPercent
	}
	return 0
}

type Status_Disk_IO struct {
	ReadCount        uint64 `protobuf:"varint,1,opt,name=readCount,proto3" json:"readCount,omitempty"`
	MergedReadCount  uint64 `protobuf:"varint,2,opt,name=mergedReadCount,proto3" json:"mergedReadCount,omitempty"`
	WriteCount       uint64 `protobuf:"varint,3,opt,name=writeCount,proto3" json:"writeCount,omitempty"`
	MergedWriteCount uint64 `protobuf:"varint,4,opt,name=mergedWriteCount,proto3" json:"mergedWriteCount,omitempty"`
	ReadBytes        uint64 `protobuf:"varint,5,opt,name=readBytes,proto3" json:"readBytes,omitempty"`
	WriteBytes       uint64 `protobuf:"varint,6,opt,name=writeBytes,proto3" json:"writeBytes,omitempty"`
	ReadTime         uint64 `protobuf:"varint,7,opt,name=readTime,proto3" json:"readTime,omitempty"`
	WriteTime        uint64 `protobuf:"varint,8,opt,name=writeTime,proto3" json:"writeTime,omitempty"`
	IopsInProgress   uint64 `protobuf:"varint,9,opt,name=iopsInProgress,proto3" json:"iopsInProgress,omitempty"`
	IoTime           uint64 `protobuf:"varint,10,opt,name=ioTime,proto3" json:"ioTime,omitempty"`
	WeightedIO       uint64 `protobuf:"varint,11,opt,name=weightedIO,proto3" json:"weightedIO,omitempty"`
	Name             string `protobuf:"bytes,12,opt,name=name,proto3" json:"name,omitempty"`
	SerialNumber     string `protobuf:"bytes,13,opt,name=serialNumber,proto3" json:"serialNumber,omitempty"`
	Label            string `protobuf:"bytes,14,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *Status_Disk_IO) Reset()         { *m = Status_Disk_IO{} }
func (m *Status_Disk_IO) String() string { return proto.CompactTextString(m) }
func (*Status_Disk_IO) ProtoMessage()    {}
func (*Status_Disk_IO) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0, 5, 2}
}
func (m *Status_Disk_IO) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Disk_IO) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Disk_IO.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Disk_IO) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Disk_IO.Merge(m, src)
}
func (m *Status_Disk_IO) XXX_Size() int {
	return m.Size()
}
func (m *Status_Disk_IO) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Disk_IO.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Disk_IO proto.InternalMessageInfo

func (m *Status_Disk_IO) GetReadCount() uint64 {
	if m != nil {
		return m.ReadCount
	}
	return 0
}

func (m *Status_Disk_IO) GetMergedReadCount() uint64 {
	if m != nil {
		return m.MergedReadCount
	}
	return 0
}

func (m *Status_Disk_IO) GetWriteCount() uint64 {
	if m != nil {
		return m.WriteCount
	}
	return 0
}

func (m *Status_Disk_IO) GetMergedWriteCount() uint64 {
	if m != nil {
		return m.MergedWriteCount
	}
	return 0
}

func (m *Status_Disk_IO) GetReadBytes() uint64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *Status_Disk_IO) GetWriteBytes() uint64 {
	if m != nil {
		return m.WriteBytes
	}
	return 0
}

func (m *Status_Disk_IO) GetReadTime() uint64 {
	if m != nil {
		return m.ReadTime
	}
	return 0
}

func (m *Status_Disk_IO) GetWriteTime() uint64 {
	if m != nil {
		return m.WriteTime
	}
	return 0
}

func (m *Status_Disk_IO) GetIopsInProgress() uint64 {
	if m != nil {
		return m.IopsInProgress
	}
	return 0
}

func (m *Status_Disk_IO) GetIoTime() uint64 {
	if m != nil {
		return m.IoTime
	}
	return 0
}

func (m *Status_Disk_IO) GetWeightedIO() uint64 {
	if m != nil {
		return m.WeightedIO
	}
	return 0
}

func (m *Status_Disk_IO) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Status_Disk_IO) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *Status_Disk_IO) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// 隧道 请求
type TunRequest struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TunRequest) Reset()         { *m = TunRequest{} }
func (m *TunRequest) String() string { return proto.CompactTextString(m) }
func (*TunRequest) ProtoMessage()    {}
func (*TunRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{1}
}
func (m *TunRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunRequest.Merge(m, src)
}
func (m *TunRequest) XXX_Size() int {
	return m.Size()
}
func (m *TunRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TunRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TunRequest proto.InternalMessageInfo

func (m *TunRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 隧道 响应
type TunResponse struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TunResponse) Reset()         { *m = TunResponse{} }
func (m *TunResponse) String() string { return proto.CompactTextString(m) }
func (*TunResponse) ProtoMessage()    {}
func (*TunResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{2}
}
func (m *TunResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunResponse.Merge(m, src)
}
func (m *TunResponse) XXX_Size() int {
	return m.Size()
}
func (m *TunResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TunResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TunResponse proto.InternalMessageInfo

func (m *TunResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// shell 请求
type ShellRequest struct {
	Id   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ShellRequest) Reset()         { *m = ShellRequest{} }
func (m *ShellRequest) String() string { return proto.CompactTextString(m) }
func (*ShellRequest) ProtoMessage()    {}
func (*ShellRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{3}
}
func (m *ShellRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShellRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShellRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShellRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShellRequest.Merge(m, src)
}
func (m *ShellRequest) XXX_Size() int {
	return m.Size()
}
func (m *ShellRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShellRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShellRequest proto.InternalMessageInfo

func (m *ShellRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ShellRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// shell 响应
type ShellResponse struct {
	Id   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ShellResponse) Reset()         { *m = ShellResponse{} }
func (m *ShellResponse) String() string { return proto.CompactTextString(m) }
func (*ShellResponse) ProtoMessage()    {}
func (*ShellResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{4}
}
func (m *ShellResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShellResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShellResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShellResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShellResponse.Merge(m, src)
}
func (m *ShellResponse) XXX_Size() int {
	return m.Size()
}
func (m *ShellResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShellResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShellResponse proto.InternalMessageInfo

func (m *ShellResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ShellResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// status 请求
type StatusRequest struct {
	Status *Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *StatusRequest) Reset()         { *m = StatusRequest{} }
func (m *StatusRequest) String() string { return proto.CompactTextString(m) }
func (*StatusRequest) ProtoMessage()    {}
func (*StatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{5}
}
func (m *StatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusRequest.Merge(m, src)
}
func (m *StatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatusRequest proto.InternalMessageInfo

func (m *StatusRequest) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// status 响应
type StatusResponse struct {
}

func (m *StatusResponse) Reset()         { *m = StatusResponse{} }
func (m *StatusResponse) String() string { return proto.CompactTextString(m) }
func (*StatusResponse) ProtoMessage()    {}
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{6}
}
func (m *StatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusResponse.Merge(m, src)
}
func (m *StatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatusResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Status)(nil), "pb.Status")
	proto.RegisterType((*Status_Host)(nil), "pb.Status.Host")
	proto.RegisterType((*Status_Host_Info)(nil), "pb.Status.Host.Info")
	proto.RegisterType((*Status_Host_Temperature)(nil), "pb.Status.Host.Temperature")
	proto.RegisterType((*Status_Load)(nil), "pb.Status.Load")
	proto.RegisterType((*Status_CPU)(nil), "pb.Status.CPU")
	proto.RegisterType((*Status_CPU_Info)(nil), "pb.Status.CPU.Info")
	proto.RegisterType((*Status_CPU_Stat)(nil), "pb.Status.CPU.Stat")
	proto.RegisterType((*Status_Mem)(nil), "pb.Status.Mem")
	proto.RegisterType((*Status_Mem_Virtual)(nil), "pb.Status.Mem.Virtual")
	proto.RegisterType((*Status_Mem_Swap)(nil), "pb.Status.Mem.Swap")
	proto.RegisterType((*Status_Net)(nil), "pb.Status.Net")
	proto.RegisterType((*Status_Net_Info)(nil), "pb.Status.Net.Info")
	proto.RegisterType((*Status_Net_Stat)(nil), "pb.Status.Net.Stat")
	proto.RegisterType((*Status_Disk)(nil), "pb.Status.Disk")
	proto.RegisterType((*Status_Disk_Info)(nil), "pb.Status.Disk.Info")
	proto.RegisterType((*Status_Disk_Stat)(nil), "pb.Status.Disk.Stat")
	proto.RegisterType((*Status_Disk_IO)(nil), "pb.Status.Disk.IO")
	proto.RegisterType((*TunRequest)(nil), "pb.TunRequest")
	proto.RegisterType((*TunResponse)(nil), "pb.TunResponse")
	proto.RegisterType((*ShellRequest)(nil), "pb.ShellRequest")
	proto.RegisterType((*ShellResponse)(nil), "pb.ShellResponse")
	proto.RegisterType((*StatusRequest)(nil), "pb.StatusRequest")
	proto.RegisterType((*StatusResponse)(nil), "pb.StatusResponse")
}

func init() { proto.RegisterFile("pb.proto", fileDescriptor_f80abaa17e25ccc8) }

var fileDescriptor_f80abaa17e25ccc8 = []byte{
	// 1652 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0x4f, 0x6f, 0x1b, 0xbb,
	0x11, 0xf7, 0x6a, 0x57, 0xb6, 0x45, 0x39, 0x8e, 0xc3, 0x67, 0x3c, 0x2c, 0xb6, 0x81, 0xe1, 0xba,
	0x0f, 0xad, 0x1b, 0x3c, 0x18, 0xaf, 0x0e, 0x72, 0x2e, 0x12, 0x17, 0x41, 0xd4, 0x26, 0xb6, 0x41,
	0x3b, 0xe9, 0x99, 0xd2, 0x52, 0x12, 0xe1, 0xd5, 0x72, 0x43, 0x52, 0x76, 0x9d, 0x2f, 0xd0, 0x6b,
	0x2f, 0x05, 0x7a, 0x0e, 0xd0, 0x43, 0x81, 0x7c, 0x80, 0x5e, 0xd2, 0x43, 0x4f, 0x3d, 0x15, 0x39,
	0xf6, 0x58, 0x24, 0xdf, 0xa2, 0xa7, 0x62, 0x86, 0xdc, 0x5d, 0x4a, 0x4a, 0x1e, 0x72, 0x12, 0xe7,
	0x37, 0xbf, 0xe1, 0x90, 0xf3, 0x8f, 0x2b, 0xb2, 0x59, 0x0d, 0x8f, 0x2a, 0xad, 0xac, 0xa2, 0x9d,
	0x6a, 0x78, 0xf0, 0xfe, 0x3e, 0x59, 0xbf, 0xb0, 0xdc, 0xce, 0x0d, 0xfd, 0x19, 0x49, 0xa6, 0xca,
	0xd8, 0x34, 0xda, 0x8f, 0x0e, 0xfb, 0xc7, 0x77, 0x8f, 0xaa, 0xe1, 0x91, 0xd3, 0x1c, 0x3d, 0x53,
	0xc6, 0x32, 0x54, 0x02, 0xa9, 0x50, 0x3c, 0x4f, 0x3b, 0x2b, 0xa4, 0xe7, 0x8a, 0xe7, 0x0c, 0x95,
	0x74, 0x9f, 0xc4, 0xa3, 0x6a, 0x9e, 0xc6, 0xc8, 0xd9, 0x0e, 0x38, 0x27, 0xe7, 0x2f, 0x19, 0xa8,
	0x80, 0x31, 0x13, 0xb3, 0x34, 0x59, 0x61, 0xbc, 0x10, 0x33, 0x06, 0x2a, 0x60, 0x94, 0xc2, 0xa6,
	0xdd, 0x15, 0xc6, 0xa9, 0xb0, 0x0c, 0x54, 0x70, 0x94, 0x5c, 0x9a, 0xab, 0x74, 0x7d, 0xe5, 0x28,
	0xbf, 0x91, 0xe6, 0x8a, 0xa1, 0x32, 0xfb, 0x7b, 0x97, 0x24, 0x70, 0x7c, 0x7a, 0x48, 0x12, 0x59,
	0x8e, 0x95, 0xbf, 0xdd, 0xee, 0xd2, 0xed, 0x8e, 0x06, 0xe5, 0x58, 0x31, 0x64, 0xd0, 0x5f, 0x93,
	0x2d, 0x2b, 0x66, 0x95, 0xd0, 0xdc, 0xce, 0xb5, 0x30, 0x69, 0x67, 0x3f, 0x3e, 0xec, 0x1f, 0xff,
	0x64, 0xd9, 0xe2, 0xb2, 0xe5, 0xb0, 0x05, 0x83, 0xec, 0x5d, 0x4c, 0x12, 0xd8, 0x8f, 0x66, 0x64,
	0x13, 0x82, 0x56, 0xf2, 0x99, 0x40, 0xbf, 0x3d, 0xd6, 0xc8, 0xf4, 0x5b, 0xb2, 0x3e, 0xaf, 0xac,
	0x9c, 0x09, 0x0c, 0x65, 0xc2, 0xbc, 0x04, 0x36, 0x43, 0xa5, 0xec, 0x25, 0x68, 0x62, 0xd4, 0x34,
	0x32, 0xdd, 0x25, 0xdd, 0x4a, 0xab, 0x91, 0xc1, 0xb8, 0x25, 0xcc, 0x09, 0x74, 0x9b, 0x74, 0x94,
	0xc1, 0x40, 0xf5, 0x58, 0x47, 0x19, 0xd8, 0xa1, 0x2a, 0xb8, 0x1d, 0x2b, 0x3d, 0xc3, 0xd8, 0xf4,
	0x58, 0x23, 0xd3, 0x9f, 0x93, 0xed, 0x7a, 0xfd, 0x94, 0xcf, 0x64, 0x71, 0x9b, 0x6e, 0x20, 0x63,
	0x09, 0xa5, 0x87, 0xe4, 0x6e, 0x8d, 0xbc, 0x12, 0xda, 0x48, 0x55, 0xa6, 0x9b, 0x48, 0x5c, 0x86,
	0xe9, 0x77, 0xe4, 0xce, 0x95, 0xd0, 0xa5, 0x28, 0x6a, 0x5e, 0x0f, 0x79, 0x8b, 0x20, 0xdd, 0x23,
	0xc4, 0x01, 0x8f, 0xf5, 0x68, 0x9a, 0x12, 0xa4, 0x04, 0x08, 0x3d, 0x26, 0xbb, 0xd7, 0x52, 0xdb,
	0x39, 0x2f, 0xe4, 0x1b, 0x6e, 0xa5, 0x2a, 0x2f, 0x6e, 0x8d, 0x15, 0xb3, 0xb4, 0x8f, 0xcc, 0xcf,
	0xea, 0xe8, 0x11, 0xa1, 0x8b, 0x38, 0x53, 0x85, 0x48, 0xef, 0xa0, 0xc5, 0x67, 0x34, 0x10, 0x71,
	0x88, 0xfe, 0x20, 0x4f, 0xb7, 0x91, 0xe3, 0xa5, 0xec, 0xcf, 0x11, 0xe9, 0x07, 0xc9, 0xa4, 0xf7,
	0x49, 0xcf, 0x88, 0xd2, 0x28, 0xfd, 0x3b, 0x71, 0xeb, 0xd3, 0xd6, 0x02, 0x74, 0x9f, 0xf4, 0x83,
	0x64, 0x63, 0xf2, 0x22, 0x16, 0x42, 0x70, 0x57, 0x47, 0x7f, 0x26, 0x27, 0x53, 0xcc, 0x61, 0xc4,
	0x02, 0x04, 0x72, 0xe0, 0xa4, 0x13, 0x2d, 0xad, 0x1c, 0xf1, 0x02, 0xd3, 0x19, 0xb1, 0x25, 0x34,
	0xfb, 0x2d, 0x49, 0xa0, 0xa7, 0x20, 0xeb, 0xd0, 0x55, 0xbf, 0xc2, 0xb3, 0x44, 0xcc, 0x09, 0x35,
	0xfa, 0xc8, 0x9f, 0xc0, 0x09, 0x70, 0x47, 0x54, 0x3f, 0xf2, 0x7e, 0xbd, 0x94, 0xfd, 0xad, 0x4b,
	0xe2, 0x93, 0xf3, 0x97, 0xf4, 0x97, 0xa4, 0x0b, 0x35, 0x6e, 0xd2, 0x08, 0x8b, 0xfa, 0x9b, 0xc5,
	0xde, 0x74, 0x5d, 0xe0, 0x18, 0x40, 0x35, 0x96, 0xdb, 0xba, 0xfe, 0x97, 0xa9, 0xb0, 0x64, 0x8e,
	0x91, 0xfd, 0xbb, 0xe3, 0x0b, 0x7e, 0xc7, 0x35, 0x3e, 0x1c, 0xb4, 0xeb, 0x1a, 0x3d, 0x23, 0x9b,
	0xd7, 0xa2, 0xcc, 0x95, 0x1e, 0xb8, 0x99, 0xd1, 0x63, 0x8d, 0x0c, 0x87, 0x1d, 0xbb, 0x22, 0x8c,
	0x5d, 0x42, 0x9c, 0x04, 0x57, 0x9b, 0xa9, 0x5c, 0xb8, 0xb8, 0xf4, 0x98, 0x13, 0x60, 0x27, 0x63,
	0x45, 0x55, 0xc9, 0x72, 0x82, 0xc5, 0xde, 0x65, 0x8d, 0x0c, 0x21, 0xaf, 0xa6, 0xb7, 0x06, 0xc2,
	0x36, 0xc8, 0x7d, 0xd1, 0x07, 0x08, 0x78, 0x1a, 0x29, 0x2d, 0x06, 0xb9, 0x2f, 0x77, 0x2f, 0x81,
	0x27, 0x58, 0x19, 0x2c, 0xee, 0x2e, 0x73, 0x02, 0x14, 0x00, 0xba, 0x3c, 0x85, 0xbe, 0x75, 0xe5,
	0xdc, 0x02, 0x70, 0xc7, 0xd9, 0xf4, 0x0d, 0xd6, 0x70, 0xc4, 0x60, 0x09, 0xfc, 0x11, 0x1f, 0x4d,
	0xc5, 0x85, 0x7c, 0x23, 0xb0, 0x62, 0xbb, 0xac, 0x05, 0xc0, 0xc7, 0xb8, 0xe0, 0x13, 0x93, 0x6e,
	0xed, 0xc7, 0x70, 0x1b, 0x14, 0xd0, 0x87, 0x1c, 0x69, 0x35, 0x52, 0x79, 0x5d, 0xb3, 0x2d, 0x90,
	0xfd, 0x2f, 0x22, 0x09, 0x04, 0x38, 0x0c, 0x68, 0xcf, 0x05, 0x94, 0x92, 0x64, 0x6e, 0x84, 0xf6,
	0x69, 0xc7, 0x35, 0x5c, 0xcf, 0xb8, 0x7e, 0xf1, 0x59, 0x77, 0x12, 0x70, 0x65, 0x5e, 0x08, 0x5f,
	0x5f, 0xb8, 0x06, 0xac, 0x94, 0x23, 0x81, 0x21, 0x8c, 0x18, 0xae, 0xc1, 0x5e, 0xaa, 0x1b, 0x2e,
	0x2d, 0x86, 0x2e, 0x62, 0x5e, 0x02, 0xef, 0x52, 0xbf, 0xc6, 0x98, 0x45, 0x0c, 0x96, 0x34, 0x25,
	0x1b, 0x46, 0x8d, 0x2d, 0xa0, 0x9b, 0x88, 0xd6, 0x22, 0x5c, 0xd3, 0x58, 0xc1, 0x0b, 0x0c, 0x58,
	0xc4, 0x9c, 0x00, 0xe8, 0x64, 0x2e, 0x8c, 0xf5, 0xe1, 0x72, 0x02, 0x5c, 0x1e, 0x17, 0xa7, 0x70,
	0x90, 0x3e, 0x6a, 0x5a, 0x20, 0x7b, 0x1f, 0x93, 0xf8, 0x85, 0x98, 0xd1, 0x1f, 0xc8, 0x86, 0xef,
	0x62, 0x3f, 0xb4, 0xbf, 0x5d, 0x7c, 0x27, 0x8e, 0x5e, 0x39, 0x2d, 0xab, 0x69, 0xf4, 0x17, 0x24,
	0x31, 0x37, 0xbc, 0xf2, 0x8f, 0xd3, 0x37, 0x4b, 0xf4, 0x8b, 0x1b, 0x5e, 0x31, 0x24, 0x64, 0x7f,
	0x8c, 0xc8, 0x86, 0xb7, 0x86, 0x23, 0x5a, 0x65, 0xbd, 0x93, 0x84, 0x39, 0x01, 0x8e, 0xc8, 0xaf,
	0xb9, 0x2c, 0xf8, 0xb0, 0xa8, 0x27, 0x74, 0x0b, 0xf8, 0x24, 0xe4, 0x7e, 0x40, 0xe3, 0x1a, 0x06,
	0x03, 0xfc, 0x9e, 0x0b, 0x3d, 0x12, 0xa5, 0xf5, 0x31, 0x0f, 0x21, 0xb0, 0x1a, 0x6b, 0xe1, 0x42,
	0x9f, 0x30, 0x5c, 0x67, 0x1f, 0x20, 0xd3, 0x37, 0xbc, 0xfa, 0xc2, 0x31, 0x6a, 0x47, 0x9d, 0xc0,
	0x51, 0xbd, 0x4d, 0xdc, 0x6e, 0xf3, 0x15, 0xce, 0x77, 0x48, 0x6c, 0x64, 0xe9, 0x7d, 0xc3, 0x12,
	0xf6, 0x31, 0x6a, 0xee, 0x72, 0x9e, 0x30, 0x5c, 0x03, 0x56, 0x4d, 0x06, 0x25, 0xa6, 0x3c, 0x61,
	0xb8, 0xc6, 0x57, 0x67, 0x72, 0x36, 0xb7, 0x98, 0x71, 0x78, 0x75, 0x40, 0x80, 0x4a, 0xa8, 0x26,
	0x4f, 0xf9, 0xbc, 0xb0, 0x98, 0xf1, 0x84, 0xd5, 0x62, 0xf6, 0xd7, 0x84, 0xc4, 0xa7, 0xc2, 0xfe,
	0xd8, 0xac, 0x39, 0x15, 0xf6, 0x6b, 0x67, 0x0d, 0x50, 0xc3, 0x59, 0xf3, 0x97, 0xc8, 0xcf, 0x9a,
	0x5d, 0xd8, 0x3e, 0x17, 0x7f, 0xf0, 0xd3, 0xc6, 0x09, 0xd8, 0x9d, 0x76, 0x8e, 0xf1, 0xea, 0x32,
	0x58, 0x62, 0xc1, 0x73, 0xff, 0x98, 0xf6, 0x18, 0xae, 0xe9, 0x01, 0xd9, 0x9a, 0x72, 0x9d, 0xdf,
	0x70, 0x2d, 0x1e, 0xe7, 0xb9, 0xf6, 0x83, 0x66, 0x01, 0x6b, 0xfb, 0xb6, 0x1b, 0xf6, 0x6d, 0x46,
	0x36, 0x79, 0x9e, 0xeb, 0xe7, 0xd2, 0x40, 0xe0, 0x40, 0xd1, 0xc8, 0xd9, 0xbb, 0x8e, 0xef, 0xda,
	0xda, 0x65, 0x14, 0xb8, 0xbc, 0x4f, 0x7a, 0xc3, 0x5b, 0x2b, 0xcc, 0x05, 0xe4, 0xc7, 0x17, 0x54,
	0x03, 0x34, 0x5a, 0x26, 0x46, 0xd7, 0x3e, 0xb1, 0x2d, 0x00, 0xd9, 0xad, 0xf8, 0xe8, 0x4a, 0x58,
	0x67, 0xed, 0x5e, 0xff, 0x10, 0x0a, 0x18, 0xb8, 0x43, 0x77, 0x81, 0x81, 0x7b, 0xec, 0x92, 0xae,
	0xd0, 0x5a, 0x96, 0x3e, 0xdd, 0x4e, 0x80, 0xce, 0x17, 0x5a, 0x43, 0x15, 0xb8, 0x8c, 0x7b, 0x09,
	0xf0, 0x5c, 0xab, 0x4a, 0x96, 0x3e, 0xe9, 0x5e, 0x82, 0xac, 0xc3, 0x0a, 0x0c, 0x7c, 0xd6, 0xbd,
	0x88, 0xc3, 0x5c, 0x8e, 0x95, 0x2c, 0xb1, 0xd5, 0x13, 0xe6, 0x25, 0xb0, 0x80, 0x15, 0x58, 0xf4,
	0x9d, 0x85, 0x17, 0xb3, 0x7f, 0x6e, 0x90, 0x04, 0xbe, 0xd4, 0xe8, 0x83, 0xc5, 0x42, 0xd9, 0x5d,
	0xfa, 0x92, 0x5b, 0xa8, 0x94, 0x07, 0x8b, 0x95, 0xb2, 0xc2, 0x0d, 0x4a, 0x85, 0x7e, 0x47, 0x62,
	0xa9, 0x4c, 0x1a, 0x23, 0x93, 0xae, 0xec, 0x7a, 0xc6, 0x40, 0x9d, 0xbd, 0xf2, 0xf5, 0x04, 0x57,
	0x16, 0xd7, 0x30, 0x91, 0x5c, 0xda, 0xbc, 0x04, 0x6f, 0xcb, 0x4c, 0xcd, 0x4b, 0x5b, 0x29, 0xe9,
	0x33, 0xd7, 0x63, 0x01, 0x82, 0x17, 0x37, 0xf6, 0xb6, 0x12, 0xcd, 0x2b, 0x86, 0x52, 0xf6, 0x36,
	0xa8, 0x86, 0x8a, 0xdb, 0x69, 0x5d, 0x0d, 0xb0, 0x0e, 0x8c, 0x3a, 0xa1, 0x51, 0x3b, 0x05, 0xe2,
	0xa5, 0x29, 0x80, 0x1d, 0x9f, 0x04, 0x1d, 0x5f, 0x4f, 0x86, 0xee, 0x97, 0x47, 0xd0, 0xfa, 0xea,
	0x14, 0xd8, 0x27, 0x7d, 0x59, 0xaa, 0x5c, 0x98, 0x4b, 0xf4, 0xe2, 0x92, 0x1e, 0x42, 0x70, 0x5d,
	0x27, 0xbe, 0x84, 0xdd, 0x5d, 0xf6, 0x03, 0xa4, 0xd5, 0x3f, 0x85, 0x13, 0xf5, 0x42, 0x3d, 0x20,
	0xf4, 0x7b, 0x72, 0xaf, 0x65, 0xd7, 0x27, 0x71, 0xd3, 0x7f, 0x55, 0x91, 0xfd, 0x23, 0x26, 0x9d,
	0xc1, 0x19, 0x94, 0xbf, 0x16, 0x3c, 0x3f, 0x81, 0xa8, 0xfa, 0x01, 0xd8, 0x02, 0xf0, 0x31, 0x3a,
	0x13, 0x7a, 0x22, 0x72, 0xd6, 0x70, 0x5c, 0x03, 0x2d, 0xc3, 0x70, 0xb8, 0x1b, 0x2d, 0xad, 0x70,
	0x24, 0x17, 0xc3, 0x00, 0xa1, 0x0f, 0xc8, 0x8e, 0x33, 0xf9, 0x7d, 0xcb, 0x72, 0x41, 0x5d, 0xc1,
	0xeb, 0x33, 0x3d, 0x81, 0x2e, 0xf4, 0x51, 0x6e, 0x81, 0xc6, 0x93, 0x53, 0xaf, 0x07, 0x9e, 0x9c,
	0x3e, 0x23, 0x9b, 0x40, 0xc6, 0xcf, 0x78, 0x17, 0xe5, 0x46, 0x86, 0x9d, 0x91, 0x89, 0x4a, 0x17,
	0xe1, 0x16, 0x80, 0xcf, 0x43, 0xa9, 0x2a, 0x33, 0x28, 0xcf, 0xb5, 0x9a, 0x68, 0x61, 0x8c, 0x0f,
	0xf2, 0x12, 0xea, 0x1e, 0x6d, 0xdc, 0xc2, 0x37, 0x9c, 0x93, 0xf0, 0x64, 0x42, 0x4e, 0xa6, 0x56,
	0xe4, 0x83, 0x33, 0xdf, 0x73, 0x01, 0xd2, 0x0c, 0xa7, 0xad, 0xc5, 0x79, 0x68, 0x84, 0x96, 0xbc,
	0x38, 0x9d, 0xcf, 0x86, 0x42, 0xfb, 0x0f, 0x92, 0x05, 0x0c, 0x3f, 0x38, 0xf9, 0x50, 0x14, 0xfe,
	0xeb, 0xd9, 0x09, 0x07, 0xfb, 0x84, 0x5c, 0xce, 0x4b, 0x26, 0x5e, 0xe3, 0xc3, 0x4e, 0x49, 0x92,
	0x73, 0xcb, 0x31, 0x85, 0x5b, 0x0c, 0xd7, 0x07, 0x3f, 0x25, 0x7d, 0x64, 0x98, 0x4a, 0x95, 0x46,
	0x7c, 0x96, 0x72, 0x4c, 0xb6, 0x2e, 0xa6, 0xa2, 0x28, 0xea, 0x6d, 0xb6, 0x49, 0x47, 0xe6, 0xbe,
	0x5f, 0x3a, 0x32, 0x6f, 0x6c, 0x3a, 0x81, 0xcd, 0x43, 0x72, 0xc7, 0xdb, 0xf8, 0x8d, 0xbf, 0xd6,
	0x08, 0x47, 0x40, 0xed, 0xe9, 0x80, 0xac, 0x1b, 0x04, 0xfc, 0x27, 0x06, 0x69, 0xa7, 0x04, 0xf3,
	0x9a, 0x83, 0x1d, 0xb2, 0x5d, 0x1b, 0x39, 0x57, 0xc7, 0x6f, 0x23, 0xb2, 0xf1, 0x8c, 0x97, 0x79,
	0x21, 0x34, 0xfd, 0x9e, 0xc4, 0x97, 0xf3, 0x92, 0xe2, 0x3f, 0xd4, 0x36, 0x12, 0xd9, 0xdd, 0x46,
	0x76, 0x36, 0x07, 0x6b, 0x87, 0xd1, 0x0f, 0x11, 0x3d, 0x26, 0x5d, 0x3c, 0x35, 0xdd, 0x41, 0x47,
	0xc1, 0xa5, 0xb3, 0x7b, 0x01, 0xb2, 0x60, 0xf3, 0xa8, 0xf9, 0x87, 0x7e, 0x2f, 0x38, 0x9d, 0xb7,
	0xa2, 0x21, 0x14, 0x9a, 0x3d, 0x49, 0xff, 0xf5, 0x71, 0x2f, 0xfa, 0xf0, 0x71, 0x2f, 0xfa, 0xef,
	0xc7, 0xbd, 0xe8, 0x4f, 0x9f, 0xf6, 0xd6, 0x3e, 0x7c, 0xda, 0x5b, 0xfb, 0xcf, 0xa7, 0xbd, 0xb5,
	0xe1, 0x3a, 0xfe, 0xfd, 0x7f, 0xf8, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7c, 0x7d, 0xe9, 0x56,
	0x0a, 0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// HandlerClient is the client API for Handler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HandlerClient interface {
	// 网络 隧道
	Tun(ctx context.Context, opts ...grpc.CallOption) (Handler_TunClient, error)
	// shell 脚本 服务器控制
	Shell(ctx context.Context, opts ...grpc.CallOption) (Handler_ShellClient, error)
	// 状态 请求 主动上传
	Status(ctx context.Context, opts ...grpc.CallOption) (Handler_StatusClient, error)
}

type handlerClient struct {
	cc *grpc.ClientConn
}

func NewHandlerClient(cc *grpc.ClientConn) HandlerClient {
	return &handlerClient{cc}
}

func (c *handlerClient) Tun(ctx context.Context, opts ...grpc.CallOption) (Handler_TunClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Handler_serviceDesc.Streams[0], "/pb.Handler/Tun", opts...)
	if err != nil {
		return nil, err
	}
	x := &handlerTunClient{stream}
	return x, nil
}

type Handler_TunClient interface {
	Send(*TunRequest) error
	Recv() (*TunResponse, error)
	grpc.ClientStream
}

type handlerTunClient struct {
	grpc.ClientStream
}

func (x *handlerTunClient) Send(m *TunRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *handlerTunClient) Recv() (*TunResponse, error) {
	m := new(TunResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *handlerClient) Shell(ctx context.Context, opts ...grpc.CallOption) (Handler_ShellClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Handler_serviceDesc.Streams[1], "/pb.Handler/Shell", opts...)
	if err != nil {
		return nil, err
	}
	x := &handlerShellClient{stream}
	return x, nil
}

type Handler_ShellClient interface {
	Send(*ShellRequest) error
	Recv() (*ShellResponse, error)
	grpc.ClientStream
}

type handlerShellClient struct {
	grpc.ClientStream
}

func (x *handlerShellClient) Send(m *ShellRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *handlerShellClient) Recv() (*ShellResponse, error) {
	m := new(ShellResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *handlerClient) Status(ctx context.Context, opts ...grpc.CallOption) (Handler_StatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Handler_serviceDesc.Streams[2], "/pb.Handler/Status", opts...)
	if err != nil {
		return nil, err
	}
	x := &handlerStatusClient{stream}
	return x, nil
}

type Handler_StatusClient interface {
	Send(*StatusRequest) error
	Recv() (*StatusResponse, error)
	grpc.ClientStream
}

type handlerStatusClient struct {
	grpc.ClientStream
}

func (x *handlerStatusClient) Send(m *StatusRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *handlerStatusClient) Recv() (*StatusResponse, error) {
	m := new(StatusResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// HandlerServer is the server API for Handler service.
type HandlerServer interface {
	// 网络 隧道
	Tun(Handler_TunServer) error
	// shell 脚本 服务器控制
	Shell(Handler_ShellServer) error
	// 状态 请求 主动上传
	Status(Handler_StatusServer) error
}

// UnimplementedHandlerServer can be embedded to have forward compatible implementations.
type UnimplementedHandlerServer struct {
}

func (*UnimplementedHandlerServer) Tun(srv Handler_TunServer) error {
	return status.Errorf(codes.Unimplemented, "method Tun not implemented")
}
func (*UnimplementedHandlerServer) Shell(srv Handler_ShellServer) error {
	return status.Errorf(codes.Unimplemented, "method Shell not implemented")
}
func (*UnimplementedHandlerServer) Status(srv Handler_StatusServer) error {
	return status.Errorf(codes.Unimplemented, "method Status not implemented")
}

func RegisterHandlerServer(s *grpc.Server, srv HandlerServer) {
	s.RegisterService(&_Handler_serviceDesc, srv)
}

func _Handler_Tun_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HandlerServer).Tun(&handlerTunServer{stream})
}

type Handler_TunServer interface {
	Send(*TunResponse) error
	Recv() (*TunRequest, error)
	grpc.ServerStream
}

type handlerTunServer struct {
	grpc.ServerStream
}

func (x *handlerTunServer) Send(m *TunResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *handlerTunServer) Recv() (*TunRequest, error) {
	m := new(TunRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Handler_Shell_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HandlerServer).Shell(&handlerShellServer{stream})
}

type Handler_ShellServer interface {
	Send(*ShellResponse) error
	Recv() (*ShellRequest, error)
	grpc.ServerStream
}

type handlerShellServer struct {
	grpc.ServerStream
}

func (x *handlerShellServer) Send(m *ShellResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *handlerShellServer) Recv() (*ShellRequest, error) {
	m := new(ShellRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Handler_Status_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HandlerServer).Status(&handlerStatusServer{stream})
}

type Handler_StatusServer interface {
	Send(*StatusResponse) error
	Recv() (*StatusRequest, error)
	grpc.ServerStream
}

type handlerStatusServer struct {
	grpc.ServerStream
}

func (x *handlerStatusServer) Send(m *StatusResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *handlerStatusServer) Recv() (*StatusRequest, error) {
	m := new(StatusRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Handler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Handler",
	HandlerType: (*HandlerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Tun",
			Handler:       _Handler_Tun_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Shell",
			Handler:       _Handler_Shell_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Status",
			Handler:       _Handler_Status_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb.proto",
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disk != nil {
		{
			size, err := m.Disk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Net != nil {
		{
			size, err := m.Net.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Mem != nil {
		{
			size, err := m.Mem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Load != nil {
		{
			size, err := m.Load.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Host != nil {
		{
			size, err := m.Host.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Host) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Host) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Host) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Temperatures) > 0 {
		for iNdEx := len(m.Temperatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Temperatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Host_Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Host_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Host_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostId) > 0 {
		i -= len(m.HostId)
		copy(dAtA[i:], m.HostId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.HostId)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.VirtualizationRole) > 0 {
		i -= len(m.VirtualizationRole)
		copy(dAtA[i:], m.VirtualizationRole)
		i = encodeVarintPb(dAtA, i, uint64(len(m.VirtualizationRole)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.VirtualizationSystem) > 0 {
		i -= len(m.VirtualizationSystem)
		copy(dAtA[i:], m.VirtualizationSystem)
		i = encodeVarintPb(dAtA, i, uint64(len(m.VirtualizationSystem)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.KernelArch) > 0 {
		i -= len(m.KernelArch)
		copy(dAtA[i:], m.KernelArch)
		i = encodeVarintPb(dAtA, i, uint64(len(m.KernelArch)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.KernelVersion) > 0 {
		i -= len(m.KernelVersion)
		copy(dAtA[i:], m.KernelVersion)
		i = encodeVarintPb(dAtA, i, uint64(len(m.KernelVersion)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PlatformVersion) > 0 {
		i -= len(m.PlatformVersion)
		copy(dAtA[i:], m.PlatformVersion)
		i = encodeVarintPb(dAtA, i, uint64(len(m.PlatformVersion)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PlatformFamily) > 0 {
		i -= len(m.PlatformFamily)
		copy(dAtA[i:], m.PlatformFamily)
		i = encodeVarintPb(dAtA, i, uint64(len(m.PlatformFamily)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Os) > 0 {
		i -= len(m.Os)
		copy(dAtA[i:], m.Os)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Os)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Procs != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Procs))
		i--
		dAtA[i] = 0x20
	}
	if m.BootTime != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BootTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Uptime != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Uptime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Host_Temperature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Host_Temperature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Host_Temperature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SensorCritical != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SensorCritical))))
		i--
		dAtA[i] = 0x21
	}
	if m.SensorHigh != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SensorHigh))))
		i--
		dAtA[i] = 0x19
	}
	if m.Temperature != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Temperature))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.SensorKey) > 0 {
		i -= len(m.SensorKey)
		copy(dAtA[i:], m.SensorKey)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SensorKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Load) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Load) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Load) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Load15 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Load15))))
		i--
		dAtA[i] = 0x19
	}
	if m.Load5 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Load5))))
		i--
		dAtA[i] = 0x11
	}
	if m.Load1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Load1))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Status_CPU) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_CPU) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_CPU) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for iNdEx := len(m.Stats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Infos) > 0 {
		for iNdEx := len(m.Infos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Infos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Status_CPU_Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_CPU_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_CPU_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Microcode) > 0 {
		i -= len(m.Microcode)
		copy(dAtA[i:], m.Microcode)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Microcode)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Flags) > 0 {
		for iNdEx := len(m.Flags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Flags[iNdEx])
			copy(dAtA[i:], m.Flags[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Flags[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.CacheSize != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.CacheSize))
		i--
		dAtA[i] = 0x58
	}
	if m.Mhz != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mhz))))
		i--
		dAtA[i] = 0x51
	}
	if len(m.ModelName) > 0 {
		i -= len(m.ModelName)
		copy(dAtA[i:], m.ModelName)
		i = encodeVarintPb(dAtA, i, uint64(len(m.ModelName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Cores != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Cores))
		i--
		dAtA[i] = 0x40
	}
	if len(m.CoreId) > 0 {
		i -= len(m.CoreId)
		copy(dAtA[i:], m.CoreId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.CoreId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PhysicalId) > 0 {
		i -= len(m.PhysicalId)
		copy(dAtA[i:], m.PhysicalId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.PhysicalId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Stepping != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Stepping))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Family) > 0 {
		i -= len(m.Family)
		copy(dAtA[i:], m.Family)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Family)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VendorId) > 0 {
		i -= len(m.VendorId)
		copy(dAtA[i:], m.VendorId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.VendorId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cpu != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Cpu))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Status_CPU_Stat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_CPU_Stat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_CPU_Stat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GuestNice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GuestNice))))
		i--
		dAtA[i] = 0x59
	}
	if m.Guest != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Guest))))
		i--
		dAtA[i] = 0x51
	}
	if m.Steal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Steal))))
		i--
		dAtA[i] = 0x49
	}
	if m.Softirq != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Softirq))))
		i--
		dAtA[i] = 0x41
	}
	if m.Irq != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Irq))))
		i--
		dAtA[i] = 0x39
	}
	if m.Iowait != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Iowait))))
		i--
		dAtA[i] = 0x31
	}
	if m.Nice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Nice))))
		i--
		dAtA[i] = 0x29
	}
	if m.Idle != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Idle))))
		i--
		dAtA[i] = 0x21
	}
	if m.System != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.System))))
		i--
		dAtA[i] = 0x19
	}
	if m.User != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.User))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Cpu) > 0 {
		i -= len(m.Cpu)
		copy(dAtA[i:], m.Cpu)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Cpu)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Mem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Mem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Mem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Swap != nil {
		{
			size, err := m.Swap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Virtual != nil {
		{
			size, err := m.Virtual.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Mem_Virtual) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Mem_Virtual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Mem_Virtual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Free != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Free))
		i--
		dAtA[i] = 0x28
	}
	if m.UsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedPercent))))
		i--
		dAtA[i] = 0x21
	}
	if m.Used != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x18
	}
	if m.Available != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Available))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Status_Mem_Swap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Mem_Swap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Mem_Swap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PgFault != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.PgFault))
		i--
		dAtA[i] = 0x48
	}
	if m.PgOut != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.PgOut))
		i--
		dAtA[i] = 0x40
	}
	if m.PgIn != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.PgIn))
		i--
		dAtA[i] = 0x38
	}
	if m.Sout != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Sout))
		i--
		dAtA[i] = 0x30
	}
	if m.Sin != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Sin))
		i--
		dAtA[i] = 0x28
	}
	if m.UsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedPercent))))
		i--
		dAtA[i] = 0x21
	}
	if m.Free != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Free))
		i--
		dAtA[i] = 0x18
	}
	if m.Used != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Status_Net) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Net) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Net) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for iNdEx := len(m.Stats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Infos) > 0 {
		for iNdEx := len(m.Infos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Infos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Status_Net_Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Net_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Net_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddrList) > 0 {
		for iNdEx := len(m.AddrList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddrList[iNdEx])
			copy(dAtA[i:], m.AddrList[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.AddrList[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Flags) > 0 {
		for iNdEx := len(m.Flags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Flags[iNdEx])
			copy(dAtA[i:], m.Flags[iNdEx])
			i = encodeVarintPb(dAtA, i, uint64(len(m.Flags[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.HardwareAddr) > 0 {
		i -= len(m.HardwareAddr)
		copy(dAtA[i:], m.HardwareAddr)
		i = encodeVarintPb(dAtA, i, uint64(len(m.HardwareAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mtu != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Status_Net_Stat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Net_Stat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Net_Stat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fifoout != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Fifoout))
		i--
		dAtA[i] = 0x58
	}
	if m.Fifoin != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Fifoin))
		i--
		dAtA[i] = 0x50
	}
	if m.Dropout != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Dropout))
		i--
		dAtA[i] = 0x48
	}
	if m.Dropin != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Dropin))
		i--
		dAtA[i] = 0x40
	}
	if m.Errout != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Errout))
		i--
		dAtA[i] = 0x38
	}
	if m.Errin != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Errin))
		i--
		dAtA[i] = 0x30
	}
	if m.PacketsRecv != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.PacketsRecv))
		i--
		dAtA[i] = 0x28
	}
	if m.PacketsSent != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.PacketsSent))
		i--
		dAtA[i] = 0x20
	}
	if m.BytesRecv != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BytesRecv))
		i--
		dAtA[i] = 0x18
	}
	if m.BytesSent != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BytesSent))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Disk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Disk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Disk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ios) > 0 {
		for iNdEx := len(m.Ios) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ios[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Stats) > 0 {
		for iNdEx := len(m.Stats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Infos) > 0 {
		for iNdEx := len(m.Infos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Infos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Status_Disk_Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Disk_Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Disk_Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fstype) > 0 {
		i -= len(m.Fstype)
		copy(dAtA[i:], m.Fstype)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Fstype)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Mountpoint) > 0 {
		i -= len(m.Mountpoint)
		copy(dAtA[i:], m.Mountpoint)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Mountpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Disk_Stat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Disk_Stat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Disk_Stat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InodesUsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.InodesUsedPercent))))
		i--
		dAtA[i] = 0x51
	}
	if m.InodesFree != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.InodesFree))
		i--
		dAtA[i] = 0x48
	}
	if m.InodesUsed != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.InodesUsed))
		i--
		dAtA[i] = 0x40
	}
	if m.InodesTotal != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.InodesTotal))
		i--
		dAtA[i] = 0x38
	}
	if m.UsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedPercent))))
		i--
		dAtA[i] = 0x31
	}
	if m.Used != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x28
	}
	if m.Free != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Free))
		i--
		dAtA[i] = 0x20
	}
	if m.Total != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Fstype) > 0 {
		i -= len(m.Fstype)
		copy(dAtA[i:], m.Fstype)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Fstype)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Disk_IO) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Disk_IO) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Disk_IO) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.SerialNumber) > 0 {
		i -= len(m.SerialNumber)
		copy(dAtA[i:], m.SerialNumber)
		i = encodeVarintPb(dAtA, i, uint64(len(m.SerialNumber)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x62
	}
	if m.WeightedIO != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.WeightedIO))
		i--
		dAtA[i] = 0x58
	}
	if m.IoTime != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.IoTime))
		i--
		dAtA[i] = 0x50
	}
	if m.IopsInProgress != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.IopsInProgress))
		i--
		dAtA[i] = 0x48
	}
	if m.WriteTime != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.WriteTime))
		i--
		dAtA[i] = 0x40
	}
	if m.ReadTime != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadTime))
		i--
		dAtA[i] = 0x38
	}
	if m.WriteBytes != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.WriteBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.ReadBytes != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.MergedWriteCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MergedWriteCount))
		i--
		dAtA[i] = 0x20
	}
	if m.WriteCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.WriteCount))
		i--
		dAtA[i] = 0x18
	}
	if m.MergedReadCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.MergedReadCount))
		i--
		dAtA[i] = 0x10
	}
	if m.ReadCount != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.ReadCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TunRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShellRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShellRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShellRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShellResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShellResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShellResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintPb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Load != nil {
		l = m.Load.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Mem != nil {
		l = m.Mem.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Net != nil {
		l = m.Net.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Disk != nil {
		l = m.Disk.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Status_Host) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Temperatures) > 0 {
		for _, e := range m.Temperatures {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Status_Host_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Uptime != 0 {
		n += 1 + sovPb(uint64(m.Uptime))
	}
	if m.BootTime != 0 {
		n += 1 + sovPb(uint64(m.BootTime))
	}
	if m.Procs != 0 {
		n += 1 + sovPb(uint64(m.Procs))
	}
	l = len(m.Os)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.PlatformFamily)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.PlatformVersion)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.KernelArch)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.VirtualizationSystem)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.VirtualizationRole)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.HostId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Status_Host_Temperature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SensorKey)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Temperature != 0 {
		n += 9
	}
	if m.SensorHigh != 0 {
		n += 9
	}
	if m.SensorCritical != 0 {
		n += 9
	}
	return n
}

func (m *Status_Load) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Load1 != 0 {
		n += 9
	}
	if m.Load5 != 0 {
		n += 9
	}
	if m.Load15 != 0 {
		n += 9
	}
	return n
}

func (m *Status_CPU) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Status_CPU_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cpu != 0 {
		n += 1 + sovPb(uint64(m.Cpu))
	}
	l = len(m.VendorId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Stepping != 0 {
		n += 1 + sovPb(uint64(m.Stepping))
	}
	l = len(m.PhysicalId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.CoreId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Cores != 0 {
		n += 1 + sovPb(uint64(m.Cores))
	}
	l = len(m.ModelName)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Mhz != 0 {
		n += 9
	}
	if m.CacheSize != 0 {
		n += 1 + sovPb(uint64(m.CacheSize))
	}
	if len(m.Flags) > 0 {
		for _, s := range m.Flags {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	l = len(m.Microcode)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Status_CPU_Stat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.User != 0 {
		n += 9
	}
	if m.System != 0 {
		n += 9
	}
	if m.Idle != 0 {
		n += 9
	}
	if m.Nice != 0 {
		n += 9
	}
	if m.Iowait != 0 {
		n += 9
	}
	if m.Irq != 0 {
		n += 9
	}
	if m.Softirq != 0 {
		n += 9
	}
	if m.Steal != 0 {
		n += 9
	}
	if m.Guest != 0 {
		n += 9
	}
	if m.GuestNice != 0 {
		n += 9
	}
	return n
}

func (m *Status_Mem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Virtual != nil {
		l = m.Virtual.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Swap != nil {
		l = m.Swap.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Status_Mem_Virtual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovPb(uint64(m.Total))
	}
	if m.Available != 0 {
		n += 1 + sovPb(uint64(m.Available))
	}
	if m.Used != 0 {
		n += 1 + sovPb(uint64(m.Used))
	}
	if m.UsedPercent != 0 {
		n += 9
	}
	if m.Free != 0 {
		n += 1 + sovPb(uint64(m.Free))
	}
	return n
}

func (m *Status_Mem_Swap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovPb(uint64(m.Total))
	}
	if m.Used != 0 {
		n += 1 + sovPb(uint64(m.Used))
	}
	if m.Free != 0 {
		n += 1 + sovPb(uint64(m.Free))
	}
	if m.UsedPercent != 0 {
		n += 9
	}
	if m.Sin != 0 {
		n += 1 + sovPb(uint64(m.Sin))
	}
	if m.Sout != 0 {
		n += 1 + sovPb(uint64(m.Sout))
	}
	if m.PgIn != 0 {
		n += 1 + sovPb(uint64(m.PgIn))
	}
	if m.PgOut != 0 {
		n += 1 + sovPb(uint64(m.PgOut))
	}
	if m.PgFault != 0 {
		n += 1 + sovPb(uint64(m.PgFault))
	}
	return n
}

func (m *Status_Net) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Status_Net_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovPb(uint64(m.Index))
	}
	if m.Mtu != 0 {
		n += 1 + sovPb(uint64(m.Mtu))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.HardwareAddr)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if len(m.Flags) > 0 {
		for _, s := range m.Flags {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.AddrList) > 0 {
		for _, s := range m.AddrList {
			l = len(s)
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Status_Net_Stat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.BytesSent != 0 {
		n += 1 + sovPb(uint64(m.BytesSent))
	}
	if m.BytesRecv != 0 {
		n += 1 + sovPb(uint64(m.BytesRecv))
	}
	if m.PacketsSent != 0 {
		n += 1 + sovPb(uint64(m.PacketsSent))
	}
	if m.PacketsRecv != 0 {
		n += 1 + sovPb(uint64(m.PacketsRecv))
	}
	if m.Errin != 0 {
		n += 1 + sovPb(uint64(m.Errin))
	}
	if m.Errout != 0 {
		n += 1 + sovPb(uint64(m.Errout))
	}
	if m.Dropin != 0 {
		n += 1 + sovPb(uint64(m.Dropin))
	}
	if m.Dropout != 0 {
		n += 1 + sovPb(uint64(m.Dropout))
	}
	if m.Fifoin != 0 {
		n += 1 + sovPb(uint64(m.Fifoin))
	}
	if m.Fifoout != 0 {
		n += 1 + sovPb(uint64(m.Fifoout))
	}
	return n
}

func (m *Status_Disk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if len(m.Ios) > 0 {
		for _, e := range m.Ios {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	return n
}

func (m *Status_Disk_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Mountpoint)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Fstype)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *Status_Disk_Stat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Fstype)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovPb(uint64(m.Total))
	}
	if m.Free != 0 {
		n += 1 + sovPb(uint64(m.Free))
	}
	if m.Used != 0 {
		n += 1 + sovPb(uint64(m.Used))
	}
	if m.UsedPercent != 0 {
		n += 9
	}
	if m.InodesTotal != 0 {
		n += 1 + sovPb(uint64(m.InodesTotal))
	}
	if m.InodesUsed != 0 {
		n += 1 + sovPb(uint64(m.InodesUsed))
	}
	if m.InodesFree != 0 {
		n += 1 + sovPb(uint64(m.InodesFree))
	}
	if m.InodesUsedPercent != 0 {
		n += 9
	}
	return n
}

func (m *Status_Disk_IO) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadCount != 0 {
		n += 1 + sovPb(uint64(m.ReadCount))
	}
	if m.MergedReadCount != 0 {
		n += 1 + sovPb(uint64(m.MergedReadCount))
	}
	if m.WriteCount != 0 {
		n += 1 + sovPb(uint64(m.WriteCount))
	}
	if m.MergedWriteCount != 0 {
		n += 1 + sovPb(uint64(m.MergedWriteCount))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovPb(uint64(m.ReadBytes))
	}
	if m.WriteBytes != 0 {
		n += 1 + sovPb(uint64(m.WriteBytes))
	}
	if m.ReadTime != 0 {
		n += 1 + sovPb(uint64(m.ReadTime))
	}
	if m.WriteTime != 0 {
		n += 1 + sovPb(uint64(m.WriteTime))
	}
	if m.IopsInProgress != 0 {
		n += 1 + sovPb(uint64(m.IopsInProgress))
	}
	if m.IoTime != 0 {
		n += 1 + sovPb(uint64(m.IoTime))
	}
	if m.WeightedIO != 0 {
		n += 1 + sovPb(uint64(m.WeightedIO))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *TunRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *TunResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *ShellRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *ShellResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *StatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	return n
}

func (m *StatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovPb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPb(x uint64) (n int) {
	return sovPb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Status_Host{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Load == nil {
				m.Load = &Status_Load{}
			}
			if err := m.Load.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &Status_CPU{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mem == nil {
				m.Mem = &Status_Mem{}
			}
			if err := m.Mem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Net == nil {
				m.Net = &Status_Net{}
			}
			if err := m.Net.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disk == nil {
				m.Disk = &Status_Disk{}
			}
			if err := m.Disk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Host) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Host: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Host: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Status_Host_Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Temperatures = append(m.Temperatures, &Status_Host_Temperature{})
			if err := m.Temperatures[len(m.Temperatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Host_Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootTime", wireType)
			}
			m.BootTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BootTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Procs", wireType)
			}
			m.Procs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Procs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelArch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelArch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualizationSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualizationSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualizationRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualizationRole = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Host_Temperature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Temperature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Temperature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SensorKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Temperature = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorHigh", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SensorHigh = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorCritical", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SensorCritical = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Load) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Load: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Load: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Load1 = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load5", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Load5 = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load15", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Load15 = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_CPU) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPU: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPU: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &Status_CPU_Info{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &Status_CPU_Stat{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_CPU_Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stepping", wireType)
			}
			m.Stepping = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stepping |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoreId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cores |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mhz", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mhz = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			m.CacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flags = append(m.Flags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Microcode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Microcode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_CPU_Stat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.User = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.System = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Idle = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Nice = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iowait", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Iowait = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Irq", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Irq = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Softirq", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Softirq = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Steal = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Guest = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuestNice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GuestNice = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Mem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Virtual == nil {
				m.Virtual = &Status_Mem_Virtual{}
			}
			if err := m.Virtual.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Swap == nil {
				m.Swap = &Status_Mem_Swap{}
			}
			if err := m.Swap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Mem_Virtual) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Virtual: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Virtual: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedPercent = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			m.Free = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Free |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Mem_Swap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Swap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Swap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			m.Free = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Free |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedPercent = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sin", wireType)
			}
			m.Sin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sout", wireType)
			}
			m.Sout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgIn", wireType)
			}
			m.PgIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgIn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgOut", wireType)
			}
			m.PgOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgOut |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgFault", wireType)
			}
			m.PgFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgFault |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Net) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Net: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Net: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &Status_Net_Info{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &Status_Net_Stat{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Net_Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flags = append(m.Flags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddrList = append(m.AddrList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Net_Stat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesSent", wireType)
			}
			m.BytesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRecv", wireType)
			}
			m.BytesRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRecv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsSent", wireType)
			}
			m.PacketsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsRecv", wireType)
			}
			m.PacketsRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsRecv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errin", wireType)
			}
			m.Errin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errout", wireType)
			}
			m.Errout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dropin", wireType)
			}
			m.Dropin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dropin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dropout", wireType)
			}
			m.Dropout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dropout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fifoin", wireType)
			}
			m.Fifoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fifoin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fifoout", wireType)
			}
			m.Fifoout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fifoout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Disk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Disk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Disk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &Status_Disk_Info{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &Status_Disk_Stat{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ios", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ios = append(m.Ios, &Status_Disk_IO{})
			if err := m.Ios[len(m.Ios)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Disk_Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mountpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mountpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fstype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fstype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Disk_Stat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fstype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fstype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			m.Free = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Free |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedPercent = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodesTotal", wireType)
			}
			m.InodesTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodesTotal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodesUsed", wireType)
			}
			m.InodesUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodesUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodesFree", wireType)
			}
			m.InodesFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodesFree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodesUsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.InodesUsedPercent = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Disk_IO) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IO: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IO: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadCount", wireType)
			}
			m.ReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergedReadCount", wireType)
			}
			m.MergedReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MergedReadCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteCount", wireType)
			}
			m.WriteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergedWriteCount", wireType)
			}
			m.MergedWriteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MergedWriteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytes", wireType)
			}
			m.WriteBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTime", wireType)
			}
			m.ReadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTime", wireType)
			}
			m.WriteTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsInProgress", wireType)
			}
			m.IopsInProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsInProgress |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoTime", wireType)
			}
			m.IoTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightedIO", wireType)
			}
			m.WeightedIO = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeightedIO |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShellRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShellRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShellRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShellResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShellResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShellResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPb = fmt.Errorf("proto: unexpected end of group")
)
